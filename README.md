TUGAS 4
- Django UserCreationForm merupakan impor fomulir bawaan Django yang dapat membantu developer dalam membuat suatu formulir pendaftaran dalam aplikasi web. Nantinya, pengguna baru yang mendaftar ke dalam formulir tersebut dapat dengan mudah mendaftarkan diri langsung di situs web tanpa harus menulis kode untuk melakukan pendaftaran. Formulir ini biasanya digunakan dalam suatu web yang memiliki sistem otentikasi yang memungkinkan pengguna untuk mendaftar dan mengelola akun mereka di situs aplikasi web. Django UserCreationForm menawarkan beberapa kelebihan, antara lain membuat suatu formulir berbasis web mudah diakses oleh pengguna, menciptakan hubungan integrasi yang kuat dengan sistem otentikasi yang dimiliki Django, hingga memiliki kemampuan melakukan proses validasi data pengguna secara otomatis. Akan tetapi, Django UserCreationForm tidak terlepas dari beberapa kekurangan, antara lain tidak tersedianya fitur pendaftaran yang lebih kompleks sehingga seorang developer harus menambahkan fitur tersebut secara manual jika menginginkan formulir pendaftaran yang lebih kompleks serta mendesain tampilan web secara mandiri. Hal ini tidak terlepas karena Django UserCreationForm hanya memiliki tampilan web yang sederhana.
- Autentikasi adalah proses verifikasi pengguna dengan melakukan pengecekan terhadap kredensial yang dimiliki pengguna. Jika kredensial yang dilakukan saat pengecekan sesuai dengan data pengguna, mka apengguna tersebut dapat memiliki akses untuk login ke dalam suatu web/aplikasi. Contoh dari proses autentikasi, antara lain Single Factor authentication(password), 2-Factor Authentication (password yang mengharuskan konfirmasi ke akun lain seperti email atau nomor telepon), hingga Multi-Factor Authentication (proses autentikasi lebih kompleks yang biasanya melibatkan ciri fisik pengguna, seperti sidik jari atau identifikasi wajah). Sementara itu, otorisasi adalah proses yang memverifikasi bahwa suatu pengguna diizinkan untuk memiliki akses ke dalam suatu aplikasi atau melakukan suatu tindakan tertentu (misalnya menginput data dengan akun bersesuaian di dalam web) berdasarkan ketentuan yang ada. Contoh dari otorisasi ini adalah ketika mencoba mengakses file seseorang namun terkunci akibat orang tersebut tidak menambahkan kita ke dalam daftar pengakses yang diizinkan. Dalam kasus ini, kita tidak ter-otorisasi untuk mengakses atau bahkan sekadar melihat akun orang tersebut. Autentikasi dan otorisasi merupakan dua proses yang penting dalam pengembangan web. Kedua proses ini memiliki peran krusial dalam menjaga keamanan dan privasi data seseorang. Kombinasi antara autentikasi dan otorisasi membantu menciptakan lingkungan keamanan yang kuat dalam sebuah aplikasi maupun sistem dengan memastikan bahwa hanya pengguna sah dengan hak akses sesuai yang dapat mengakses sebuah aplikasi atau sistem.
- Dalam konteks aplikasi web, cookies adalah salah satu cara melakukan holding state dengan memanfaatkan session ID yang disimpan. Session ID ini nantinya akan disimpan dalam bentuk cookies pada komputer yang bersangkutan. Session ID sendiri merupakan suatu "token" yang menyimpan informasi seperti username, nama, serta password dari klien. Cookies digunakan untuk menyimpan informasi yang dapat diakses oleh server atau aplikasi web saat pengguna kembali ke situs tersebut. Django sendiri memanfaatkan cookies untuk hal serupa. Untuk memastikan cookies dapat dimanfaatkan oleh Django, sebelumnya perlu dipastikan beberapa tahapan telah terpenuhi, di antaranya memastikan terdapat pesan "django.contrib.sessions.middleware.SessionMiddleware" di dalam "MIDDLEWARE" yang terdapat pada berkas setting.py. Django sendiri menggunakan cookies dengan melalui mekanisme session framework dimana Django dapat menyimpan dan mengambil data sesi pengguna dengan mudah menggunakan cookies. 
- Secara default, pada aplikasi web, penggunaan cookies merupakan suatu hal yang cukup lumrah dan aman bagi pengguna. Umumnya, cookies digunakan untuk menyimpan data dalam sesi pengguna serta mengidentifikasi pengguna. Akan tetapi, terdapat beberapa risiko yang dapat terjadi akibat pemakaian cookies. Beberapa contoh dari risiko tersebut, antara lain terjadinya serangan Cross-Site Scripting (XSS) dimana penyerang akan memasukkan kode berbahaya ke dalam cookies yang akan dieksekusi oleh pengguna lain saat mereka mengakses situs tersebut, peretasan sesi dimana peretas mengambil alih sesi pengguna yang sah sehingga mengakibatkan akses yang tidak sah masuk ke dalam akun pengguna tersebut, serta penyadapan yang dapat berujung pada pencurian data sensitif pengguna.  
- Pertama, saya melakukan import UserCreationForm serta messages agar nantinya pengguna dapat dengan mudah melakukan pendaftaran saat mengakses formulir ini melalui web serta developer dapat dengan mudah memunculkan pesan pada halaman web. Selanjutnya, saya menambahkan kode dengan method post pada fungsi register serta mengimplementasikan UserCreationForm pada variabel form dan messages yang tadi sudah diimpor pada fungsi tersebut sehingga program dapat menampilkan pesan kepada pengguna setelah melakukan suatu aksi. Kemudian, saya membuat file baru bernama register.html pada folder templates yang terdapat di main sebagai file yang nantinya akan menampilkan halaman ketika pengguna melakukan register. Selanjutnya, saya melakukan update pada urls.py dengan menambahkan subdirektori serta path register. Setelah selesai membuat register, saya kemudian membuat fungsi agar pengguna dapat melakukan login dengan terlebih dahulu melakukan import authenticate dan login. Kedua import tersebut bertujuan agar program dapat melakukan autentikasi dan login jika autentikasi berhasil. Kemudian, saya menambahkan fungsi login_user pada views.py yang didalamnya terdapat kode sehingga program dapat melakukan autentikasi berdasarkan username dan password yang diterima dari permintaan (request) yang dikirim oleh pengguna saat login. Sebagaimana langkah sebelumnya saat membuat laman register, saya kemudian membuat suatu file bernama login.html di folder main/templates serta melakukan update subdirektori serta path di urls.py sehingga pengguna dapat melakukan login pada page tersebut. Setelah fungsi login, saya kemudian membuat fungsi logout_user pada views.py yang berfungsi menghapus sesi pengguna serta mengarahkan pengguna ke halaman login ketika nantinya pengguna menekan tombol logout. Setelah itu, saya membuat melakukan modifikasi pada file main.html untuk membuat tombol logout dengan fungsi yang telah disebutkan diatas. Setelah itu agar tombol dapat berfungsi, seperti langkah sebelumnya saya melakukan update subdirektori serta path pada urls.py. Setelah program saya sudah dapat melakukan login, logout, dan register akun pengguna, saya kemudian menambahkan kode pada fungsi show_main sehingga web yang saya ounya dapat terestriksi (halaman main hanya dapat diakses oleh pengguna yang sudah login (terautentikasi)). Setelah semua langkah tersebut telah berfungsi dengan baik, saya kemudian menambahkan cookies pada web saya dengan menambahkan data last login dan menampilkannya ke halaman main. Penambahan cookies ini dilakukan dengan melakukan modifikasi pada fungsi login_user dengan menambahkan `response.setcookie('last_login', str(datetime.datetime.now())) yang berfungsi untuk membuat _cookie last_login dan menambahkannya ke dalam response. Kemudian, pada fungsi show_main juga ditambahkan potongan kode 'last_login': request.COOKIES['last_login'] pada variabel context yang berfungsi menambahkan informasi cookie last_login dan menampilkan pesan tersebut pada halaman main. Setelah itu, fungsi logout_user juga mengalami sedikit modifikasi dengan menambahkan kode response.delete_cookie('last_login') berfungsi untuk menghapus cookie last_login saat pengguna melakukan logout. Kemudian, untuk menampilkan pesan last login, saya melakukan pemanggilan variabel last_login di dalam file main.html. Setelah langkah penambahan cookies sudah selesai, saya kemudian membuat dua akun pengguna yang masing-masing berisi tiga dummy data pada web saya sebagaimana yang tertera pada checklist tugas ini. Setelah berhasil membuat dua akun berbeda, saya kemudian melanjutkan pembuatan aplikasi yang saya punya dengan menghubungkan model Item dengan User. Untuk melakukan langkah ini, pertama saya melakukan import User pada models.py serta menambahkan variabel user pada class Item yang didalamnya terdapat method ForeignKey. ForeignKey sendiri digunakan untuk mendefinisikan many-to-one relationship dimana banyak item dapat terkait dengan satu pengguna tertentu. Selanjutnya, juga dilakukan modifikasi pada class create_file di views.py dengan menambahkan commit=False pada product.save agar Django tidak langsung menyimpan objek yang telah dibuat dari form ke database. Selain itu, fungsi show_main juga mengalami sedikit modifikasi pada variabel products serta name sehingga nantinya variabel name tersebut dapat berisi username yang diinput oleh pengguna. Setelah semua langkah selesai, selanjutnya dilakukan migrations agar semua perubahan yang telah dilakukan pada models dapat ter-update. Setelah semua langkah dan fungsionalitas web yang tertera pada checklist sudah dapat berjalan dengan baik, saya kemudian menambahkan beberapa fitur yang dituliskan pada bonus, yaitu fitur untuk menambah/mengurangi jumlah item serta fitur untuk menghapus item dari tabel. Pertama, saya membuat fungsi tambah_amount pada views.py yang nantinya berfungsi untuk menambah jumlah item pada tabel sebanyak 1 ketika tombol "Tambah Amount" ditekan. Pada fungsi ini, selain parameter request, saya juga menambahkan parameter id sehingga nantinya pengguna dapat menambahkan jumlah item sesuai dengan id yang bersesuaian. Saya juga memanfaatkan fungsi get_object_or_404 untuk mencegah error saat hendak menambah/menguarangi amount dari database. Kemudian, saya menambahkan fungsi tambah_amount yang saya punya ke dalam subdirektori serta path yang terdapat di urls.py. Setelah itu, saya kemudian langsung memodifikasi tabel yang ada di main.html untuk membuat kolom baru yang akan berisi tombol "Tambah Amount" pada setiap item yang saya punya. Setelah memastikan tombol tersebut sudah berfungsi dengan baik, saya kemudian melakukan langkah yang sama untuk membuat tombol lain bernama "Kurangi Amount" yang nantinya berfungsi untuk mengurangi jumlah item sebanyak 1 ketika tombol tersebut ditekan. Perbedaan dari fungsi kurangi_amount dengan fungsi tambah_amount hanya terdapat pada line product.amount -= 1 yang saya letakkan didalam indentasi jika product.amount bernilai lebih dari 0 untuk memastikan pengurangan produk akan berhenti jika jumlah item telah bernilai 0. Setelah tombol tambah dan kurangi amount sudah dapat berfungsi dengan baik, saya kemudian membuat fitur yang dapat menghapus suatu item dari tabel inventori. Pertama, saya membuat fungsi delete_item pada views.py yang juga berisi parameter request dan id. Pada fungsi ini saya menggunakan kondisi request.method == "POST" untuk memastikan eksekusi penghapusan item hanya akan dilakukan jika dilakukan method post. Setelah fungsi delete_amount selesai dibuat, saya lalu menambahkan subdirektori serta path delete pada urls.py. Setelah itu, saya kemudian menuju main.html untuk membuat tombol "Hapus Produk" yang akan berfungsi menghapus item dari tabel di setiap item yang terdapat pada tabel. Setelah ketiga tombol tambahan yang dibuat, yaitu "Tambah Amount", "Kurangi Amount", dan "Hapus Produk" sudah dapat berfungsi dengan baik, saya kemudian membuat header untuk ketiga tombol tersebut yang bernama "Fitur". Saya memanfaatkan colspan="3" agar header tersebut dapat berada tepat di tengah ketiga tombol. Saya juga melakukan modifikasi pada tabel dengan menambahkan border pada bagian pinggir tabel. Kemudian, saya juga menambahkan sedikit desain pada laman main dengan menambahkan warna background dan tabel dengan style, serta menambahkan warna pada tombol-tombol fitur yang ada pada tabel.<br>

TUGAS 3
- Apa perbedaan antara form POST dan form GET dalam Django? <br>
Jawab: form POST digunakan untuk request yang dapat digunakan untuk membuat perubahan pada sistem (perubahan pada database). Form POST digunakan untuk mengembalikan login form Django di mana browser menggabungkan data formulir, mengkodekannya untuk transmisi, mengirimkannya ke server, dan kemudian menerima kembali responsnya; form GET digunakan untuk menggabungkan data yang dikirim ke dalam string kemudian menggunakannya untuk membuat URL yang nantinya berisi berisi alamat, kunci, serta nilai data. Form GET sebaiknya hanya digunakan untuk request yang tidak mempengaruhi keadaan sistem, seperti formulir pencarian web yang dapat diwakili dengan URL.
- Apa perbedaan utama antara XML, JSON, dan HTML dalam konteks pengiriman data? <br>
Jawab: XML merupakan sebuah markup language yang didesain untuk membawa data (bukan menyimpan data). XML dapat membuat sandi kode dalam format yang dapat dibaca oleh manusia dan mesin. Dalam penyajiannya, XML menggunakan format tag structure untuk menampilkan item setiap data; JSON merupakan sebuah lightweight data-interchange format dengan basis JavaScript. JSON merepresentasikan data suatu program dalam bentuk objek serta menyimpannya dalam bentuk key dan value; HTML merupakan sebuah markup language yang secara umum digunakan untuk membuat konten dan tampilan sebuah web. HTML memungkinkan developer membuat struktur bagian, paragraf, dan tautan menggunakan elemen HTML (blok penyusun halaman web) seperti tag dan atribut.
- Mengapa JSON sering digunakan dalam pertukaran data antara aplikasi web modern? <br>
Jawab: JSON sering digunakan dalam pertukaran data antara aplikasi web modern karena ia menawarkan fleksibilitas, kesederhanaan, dan efisiensi bagi developer dalam mengoperasikannya. Tidak seperti XML yang mengharuskan developer untuk menentukan tipe data di setiap node, JSON hanya megharuskan developer untuk menentukan tipe data pada tingkat paling atas. Selain itu, karena JSON merepresentasikan data dalam bentuk objek, JSON menjadi lebih mudah untuk dibaca dibanding dengan XML. Selain itu, JSON juga mudah untuk digunakan dalam melakukan komunikasi antara berbagai komponen aplikasi web modern, termasuk antara klien (browser) dan server, serta dalam pertukaran data antara layanan web (API)
- Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step <br>
Jawab: Sebelum mulai membuat input form, terlebih dahulu saya melakukan routing serta mengimplementasikan skeleton dengan membuat folder templates di root folder yang berisi file base.html serta menambahkan BASE_DIR pada settings.py agar kode pada base.html terdeteksi sebagai template dari app ini. Selanjutnya, saya juga membuat modifikasi pada main.html yang menandaan bahwa kode tersebut menggunakan base.html sebagai template utama. Kemudian, saya membuat file forms.py yang berfungsi membuat struktur form yang akan berisi input objek model. Sebagaimana model yang telah saya buat sebelumnya, forms.py yang saya buat memiliki tiga fields, yaitu "name", "amount", dan "description". Saya juga melakukan modifikasi dengan mengubah Product menjadi Item sesuai dengan nama model yang saya punya sebelumnya. Setelah menambahkan beberapa import yang akan digunakan didalam program, saya membuat fungsi baru bernama create_product pada file views.py serta memodifikasi fungsi show_main dengan membuat variabel products untuk mengambil semua object item dari database. Selanjutnya, saya menambahkan nama fungsi baru yang sudah dibuat ke dalam file urls.py pada main serta menambahkan path url dengan nama fungsi yang bersesuaian. Selanjutnya, saya membuat file create_product.html pada folder templates yang ada di main untuk menginisiasi input product dalam bentuk table. Selanjutnya, pada main.html juga ditambahkan {% block content %} untuk menampilkan data produk dalam bentuk table serta tombol "Tambah Isi Stok" yang akan redirect ke halaman form. Kemudian agar dapat melihat objek dalam bentuk HTML, XML, JSON, XML by ID, dan JSON by ID, saya menambahkan empat fungsi tambahan, yaitu show_xml, show_json, show_xml_by_id, dan show_json_by_id. Sementara itu, tampilan data dalam format html sudah di cover dalam fungsi show_main sehingga tidak perlu lagi dibuat fungsi bernama show_html. Untuk melihat objek dalam kelima format tersebut, saya memanfaatkan postman dengan terlebih dahulu mengaktifkan runserver pada virtual environment sehingga saya dapat melihat tampilan objek dalam lima format tersebut. Setelah semua program hingga tampilan melalui postman sudah berjalan sebagaimana seharusnya, saya kemudian menambahkan counter untuk men-detect jumlah item yang disimpan pada tabel dengan menambahkan variabel product_count dengan method count yang berfungsi untuk menghitung jumlah produk pada file view.py serta menambahkan variabel tersebut ke dalam context. Kemudian, saya menambahkan variabel product_count pada file main.html sehingga jumlah produk yang terdapat di tabel dapat dilihat oleh user.
- Tampilan HTML
![FormatHtml](FormatHtml.jpg)
- Tampilan XML
![FormatXml](FormalXml.jpg)
- Tampilan JSON
![FormatJson](FormatJson.jpg)
- Tampilan XML by ID
![FormatXmlById](FormalXmlById.jpg)
- Tampilan JSON by ID
![FormatJsonById](FormatJsonById.jpg) <br>
=======================================

TUGAS 2
- Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step (bukan hanya sekadar mengikuti tutorial). <br>
Jawab: Pertama, saya membuat direktori bernama stok_tokoku yang digunakan sebagai folder utama dalam membangun web ini. Untuk membuat sebuah proyek Django baru sebagaimana pada checklist soal, tentunya saya harus mengaktifkan virtual environment untuk memudahkan proses pengerjaan saya. Setelah berhasil memastikan virtual environment saya berhasil diaktifkan, langkah selanjutnya yang cukup krusial yakni membuat file requirement.txt untuk membuat dependencies yang diperlukan dalam proses aktivasi proyek Django. Dua langkah selanjutnya yang tidak boleh terlewat yakni memasang dependencies tersebut dengan menjalankan perintah pip install -r requirements.txt dan membuat proyek Django dengan perintah django-admin startproject stok_tokoku ., dalam melakukan rangkaian proses ini hingga menjalankan server, saya mengacu pada command yang dijelaskan pada tutorial untuk membantu dan memastikan pekerjaan yang saya lakukan sudah sesuai dan tidak terdapat suatu langkah yang terlewat dalam proses pembuatan proyek Django saya. Setelah memastikan proyek Django telah berhasil dibuat, saya kemudian membuat repository baru pada github serta melakukan inisiasi repo tersebut. Setelah menambahkan file .gitignore serta README.md, saya memutuskan untuk melakukan git add, commit, dan push ke repo yang telah saya buat untuk setidaknya menyimpan progres pekerjaan yang telah saya lakukan. Setelah semua file yang telah saya buat sudah berada di repo saya sebagaimana semestinya, dengan diawali dengan mengaktifkan virtual environment, saya membuat serta mendaftarkan aplikasi main pada proyek saya. Tidak lupa, saya menambahkan folder templates pada main sekaligus menambahkan file main.html sebagai wadah untuk membangun tampilan website saya. Setelah memastikan tidak ada langkah yang terlewat dalam proses ini, saya melakukan modifikasi pada models.py yang ada di main sesuai dengan ketentuan yang diberikan pada tugas 2. Setelah models.py telah sesuai dengan yang diinginkan oleh soal, saya melakukan migrasi untuk mengubah struktur tabel basis data sesuai dengan perubahan model yang telah saya definisikan. Tidak hanya melakukan modifikasi pada models.py, saya juga melakukan beberapa modifikasi serta tambahan pada views.py serta memsatikan sudah terdapat deklarasi fungsi serta perintah render yang berfungsi untuk mengintegrasikan komponen MVT pada proyek saya. Tidak hanya itu, tentunya saya juga melakukan memodifikasi main.html sehingga saya dapat membuat tampilan web sesuai yang saya inginkan. Setelah semua proses serta tampilan web kira-kira sudah sesuai dengan keinginan saya, saya kemudian melakukan routing agar proyek yang saya buat dapat dijalankan. Setelah semua proses selesai, saya kemudian melakukan git add, commit, dan push dan kemudian melakuan deployment ke Adaptable.
- Buatlah bagan yang berisi request client ke web aplikasi berbasis Django beserta responnya dan jelaskan pada bagan tersebut kaitan antara urls.py, views.py, models.py, dan berkas html. <br>
Jawab:
![GambarBagan](<bagan request client.jpg>)
Setelah membuat suatu proyek Django, request client pertama kali akan diterima oleh urls.py. Selanjutnya, urls.py akan mendefinisikan pola URL dan mengarahkan request client ke fungsi view yang sesuai, dalam hal ini mengarahkan ke views.py. Di dalam views.py, terdapat beberapa kode yang akan mengatur jalannya aplikasi serta berinteraksi dengan model untuk mengambil atau memanipulasi data yang dibutuhkan untuk merender halaman HTML yang akan dikirimkan ke client. Kemudian, views.py dapat berinteraksi dengan models.py untuk melakukan pengambilan atau penyimpanan data ke database. Setelah melakukan operasi yang dibutuhkan, view akan merender main.html yang didalamnya terdapat variabel-variabel yang diisi dengan data yang diberikan oleh view. Setelah template (dalam hal ini main.html) berhasil di-render, isi dari file html tersebut kemudian akan diteruskan kembali ke client melalui web browser. Untuk ilustrasi bagan yang lebih lengkap dapat dilihat pada [LINK](Django-work-flow.jpg) berikut.
- Jelaskan mengapa kita menggunakan virtual environment? Apakah kita tetap dapat membuat aplikasi web berbasis Django tanpa menggunakan virtual environment? <br>
Jawab: Virtual environment digunakan untuk mengisolasi package serta dependencies dari aplikasi sehingga tidak bertabrakan dengan versi lain yang ada pada komputer. Fungsi utama virtual environment yakni memungkinkan isolasi dependensi yang memiliki versi Python berbeda pada setiap proyek yang dikerjakan. Hal ini membantu mencegah konflik dan masalah dependensi yang mungkin terjadi ketika dua proyek membutuhkan versi yang berbeda dari paket yang sama. Selain itu, Virtual environment membuat suatu proyek lebih mudah dibagikan bersama orang lain. Karena semua dependensi proyek disimpan dalam lingkungan terisolasi, orang lain dapat membuat lingkungan yang sama untuk menjalankan proyek yang sama tanpa khawatir terjadi konflik dengan paket lain di sistem mereka. Akan tetapi, kita dapat membuat aplikasi web berbasis Django tanpa menggunakan virtual environment dengan konsekuensi lebih sulit untuk mengelola dependensi, sulit jika perlu menggunakan versi Python berbeda dalam suatu proyek, hingga sulit untuk membuat proyek bersama orang lain. Oleh karena itu, untuk menjaga kebersihan, isolasi, dan manajemen dependensi yang lebih baik, sangat dianjurkan untuk menggunakan virtual environment dalam membuat aplikasi web berbasis Django.
- Jelaskan apakah itu MVC, MVT, MVVM dan perbedaan dari ketiganya <br>
Jawab: MVC, MVT, MVVM adalah tiga konsep arsitektur perangkat lunak yang digunakan dalam pengembangan aplikasi berbasis web. MVC (Model View Controller) bertangung jawab terhadap tampilan (view) serta mengatur alur kontrol (controller). MVC bertanggung jawab untuk mengambil, menyimpan, dan memproses data; menampilkan data dari Model dan menyediakan interface bagi pengguna untuk berinteraksi dengan aplikasi; menangani input pengguna dan memperbarui Model dan Tampilan yang sesuai. Jika dalam mengembangkan aplikasi berbasis user interface biasanya digunakan MVC, pada aplikasi berbasis Django digunakan MVT (Model View Template). MVT merupakan konsep yang memungkinkan pengembang web untuk mengorganisasi dan mengelola kode dengan lebih terstruktur. Sementara itu, MVVM (Model View-View Model) merupakan konsep yang memungkinkan pengikatan data dua arah, yang memudahkan pemutakhiran otomatis tampilan ketika data pada model berubah. Karena alasan tersebut, MVVM biasanya digunakan untuk membangun suatu aplikasi yang membutuhkan update berkala seperti aplikasi pada android atau ios. Perbedaan utama antara ketiganya yakni dalam cara mereka mengorganisasi dan memisahkan komponen-komponen utama dalam suatu proyek/aplikasi. Untuk MVC dan MVT, perbedaan utama terletak pada bagian controller dimana pada MVT Django mengganti controller dengan Template yang nantinya berisi sebuah file HTML. Sementara itu, MVVM menekankan pengikatan data dua arah melalui ViewModel untuk memfasilitasi pengembangan aplikasi yang lebih dinamis serta membuat suatu aplikasi lebih mudah dipelihara dan dikembangkan tanpa perlu menulis kode baru.